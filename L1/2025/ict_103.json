{
  "courseId": "ICT103",
  "courseTitle": "Programmation en C",
  "chapters": [
    {
  "courseId": "ICT103",
  "courseTitle": "Programmation en C",
  "chapterId": "ch1",
  "chapterTitle": "Introduction et fondements du langage C",
  "lessons": [
    {
      "lessonId": "l0",
      "title": "Avant de commencer — prérequis, progression et objectifs",
      "content": [
        { "type": "title", "value": "Avant de commencer" },
        { "type": "text", "value": "Ce chapitre pose les fondations : concepts, outils et bonnes pratiques nécessaires pour écrire, compiler et exécuter des programmes en C. La progression est conçue pour accompagner un étudiant du niveau L1 jusqu'à L2 : on commence par l'essentiel et on ajoute de la profondeur." },
        { "type": "smallTitle", "value": "Prérequis techniques et pédagogiques" },
        { "type": "text", "value": "- Savoir ouvrir un terminal et exécuter des commandes de base.\n- Connaissances informatiques minimales (fichiers, notions de programme et d'exécution).\n- Avoir accès à une machine avec un compilateur (GCC ou clang) ou une VM/instance cloud." },
        { "type": "smallTitle", "value": "Pré-requis pédagogiques (liens entre chapitres)" },
        { "type": "text", "value": "Avant d'aborder les chapitres suivants il est utile d'avoir lu les sections théoriques précédentes ou d'avoir des connaissances équivalentes : par exemple la notion de variable (sera approfondie au ch2) et la gestion de l'environnement (éditeurs, terminal) qui s'apprend ici." },
        { "type": "smallTitle", "value": "Objectifs du chapitre" },
        { "type": "text", "value": "À la fin de ce chapitre vous devrez :\n1. Expliquer ce qu'est le langage C et ses usages.\n2. Compiler et exécuter un programme simple.\n3. Connaître la chaîne de compilation et flags utiles.\n4. Utiliser les outils de base pour déboguer et détecter des fuites mémoire.\n5. Appliquer des bonnes pratiques de style et d'organisation." },
        { "type": "note", "value": "Ce chapitre inclut des exercices pratiques et des quiz pour valider la compréhension. Les indications fournies aident sans livrer la solution complète immédiatement." },
        {
          "type": "quiz",
          "question": "Quel item est un prérequis recommandé pour suivre ce chapitre ?",
          "options": [
            "Savoir programmer en C++",
            "Accès à un terminal et/ou compilateur",
            "Avoir lu un livre sur l'OS interne du processeur"
          ],
          "answer": 1,
          "explanation": "L'essentiel est de pouvoir compiler et exécuter du code ; un terminal et un compilateur sont requis."
        }
      ],
      "minTimeRead": "5",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l1",
      "title": "Contexte, historique et domaines d'application",
      "content": [
        { "type": "title", "value": "Contexte et histoire du C" },
        { "type": "text", "value": "Le langage C a été conçu pour donner un contrôle direct sur le matériel tout en restant relativement simple. Sa conception facilite la lecture du code machine conceptuel et la portabilité à travers différents systèmes. Comprendre l'histoire aide à saisir pourquoi certaines conventions existent (ex : gestion manuelle de la mémoire)." },
        { "type": "smallTitle", "value": "Domaines d'application" },
        { "type": "text", "value": "C est majoritairement utilisé pour :\n- systèmes d'exploitation et noyaux,\n- développement embarqué et firmware,\n- bibliothèques performantes et moteurs (game engines),\n- compilateurs et outils bas-niveau." },
        { "type": "note", "value": "Les principes appris en C sont transférables vers beaucoup de technologies : compréhension de la mémoire, performance, modèles d'exécution." },
        { "type": "exercise", "value": "Rédigez 3 cas concrets (en 1–2 phrases chacun) où le C est un meilleur choix que Python.", "indication": "Pensez à latence, accès direct à la mémoire et taille binaire." },
        {
          "type": "quiz",
          "question": "Dans quel domaine le C est-il historiquement et couramment utilisé ?",
          "options": [
            "Développement front-end web",
            "Noyaux et drivers",
            "Analyse de données (machine learning)"
          ],
          "answer": 1,
          "explanation": "Le C est un langage bas-niveau très utilisé pour les noyaux et drivers."
        }
      ],
      "minTimeRead": "8",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l2",
      "title": "Structure d'un programme C et conventions de base",
      "content": [
        { "type": "title", "value": "Anatomie d'un programme C" },
        { "type": "text", "value": "Un programme C contient généralement : déclarations (`#include`), fonctions, et le point d'entrée `main`. Respecter la structure facilite la lecture, le débogage et la maintenance." },
        { "type": "code", "language": "c", "value": "#include <stdio.h>\n\nint main(void) {\n    printf(\"Bonjour, monde !\\n\");\n    return 0;\n}" },
        { "type": "smallTitle", "value": "Explication pas à pas" },
        { "type": "text", "value": "- `#include <stdio.h>` : inclusion des prototypes d'entrées/sorties.\n- `int main(void)` : signature standard du point d'entrée.\n- `printf` : fonction d'affichage.\n- `return 0;` : convention indiquant un succès." },
        { "type": "note", "value": "Utilisez des commentaires courts pour expliquer l'intention (// ou /* ... */). Evitez le commentaire redondant." },
        { "type": "exercise", "value": "Modifiez le programme pour afficher votre prénom et un message différent sur deux lignes.", "indication": "Utilisez deux appels à printf ou un seul avec '\\n'." },
        {
          "type": "quiz",
          "question": "Quelle convention indique que le programme s'est terminé correctement ?",
          "options": [
            "return 0;",
            "exit(1);",
            "printf(\"OK\");"
          ],
          "answer": 0,
          "explanation": "Par convention, `return 0;` indique au système que le programme a réussi."
        }
      ],
      "minTimeRead": "9",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l3",
      "title": "Chaîne de compilation : préprocesseur, compilation et linkage",
      "content": [
        { "type": "title", "value": "Comprendre chaque étape" },
        { "type": "text", "value": "La transformation source → exécutable passe par : préprocessing (gestion des macros et includes), compilation (génération d'objets .o), et linking (assemblage final). Chacune a ses artefacts et outils pour inspection." },
        { "type": "smallTitle", "value": "Commandes de base (gcc)" },
        { "type": "code", "language": "bash", "value": "gcc -std=c11 -Wall -Wextra -c main.c -o main.o\ngcc main.o -o main" },
        { "type": "note", "value": "Le flag `-c` compile sans lier ; `-Wall -Wextra` affiche des warnings utiles ; `-std=c11` fixe la norme." },
        { "type": "smallTitle", "value": "Inspecter les étapes" },
        { "type": "text", "value": "Vous pouvez demander au compilateur de produire les sorties intermédiaires (préprocessed) : `gcc -E main.c -o main.i`." },
        { "type": "exercise", "value": "Produisez le fichier préprocessed `main.i` et inspectez-le pour voir les résultats de `#include`.", "indication": "Utilisez `gcc -E main.c -o main.i` puis ouvrez main.i dans l'éditeur." },
        {
          "type": "quiz",
          "question": "Quelle commande produit le fichier préprocessed ?",
          "options": [
            "gcc -E main.c -o main.i",
            "gcc -c main.c -o main.o",
            "gcc main.o -o main"
          ],
          "answer": 0,
          "explanation": "`-E` demande le préprocessing uniquement."
        }
      ],
      "minTimeRead": "10",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l4",
      "title": "Flags utiles, optimisation et mode debug",
      "content": [
        { "type": "title", "value": "Choisir les bons flags" },
        { "type": "text", "value": "Pendant le développement, privilégiez `-g` (debug) et `-O0` (pas d'optimisation) pour faciliter le debugging. Pour la production, utilisez `-O2` ou `-O3` selon vos besoins et tests." },
        { "type": "code", "language": "bash", "value": "gcc -std=c11 -Wall -Wextra -g -O0 main.c -o main # dev\ngcc -std=c11 -O2 main.c -o main # release" },
        { "type": "note", "value": "Les optimisations peuvent réorganiser le code et rendre le debugging plus difficile (variables optimisées/enregistrées)." },
        { "type": "exercise", "value": "Compilez un programme simple avec `-g` et lancez-le dans gdb ; placez un breakpoint dans `main` et inspectez une variable.", "indication": "gdb ./main ; break main ; run ; print var" },
        {
          "type": "quiz",
          "question": "Quel flag ajoute des symboles de debug dans le binaire ?",
          "options": ["-O2", "-g", "-Wall"],
          "answer": 1,
          "explanation": "Le flag `-g` inclut des symboles de debug pour les outils comme gdb."
        }
      ],
      "minTimeRead": "7",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l5",
      "title": "Éditeurs, extensions et workflow (IDE vs terminal)",
      "content": [
        { "type": "title", "value": "Choisir un workflow efficace" },
        { "type": "text", "value": "Un bon workflow combine un éditeur puissant (VS Code, CLion, Vim) et des commandes terminal pour builder/tester. Les extensions de l'éditeur peuvent fournir linting, completion et intégration debug." },
        { "type": "smallTitle", "value": "Conseils pratiques" },
        { "type": "text", "value": "- Configurez des tâches (tasks) pour compiler automatiquement.\n- Utilisez des configurations de lancement pour déboguer depuis l'éditeur.\n- Versionnez votre code (git) et écrivez des commits atomiques." },
        { "type": "note", "value": "Si vous travaillez en équipe, standardisez le style (clang-format) et fournissez un Makefile ou CMake pour la reproductibilité." },
        { "type": "exercise", "value": "Créez un `Makefile` simple pour compiler un projet avec deux sources (main.c et util.c).", "indication": "Cible : `make all` pour compiler, `make clean` pour nettoyer." },
        {
          "type": "quiz",
          "question": "Quel outil permet de standardiser le formatage du code C ?",
          "options": ["clang-format", "eslint", "prettier"],
          "answer": 0,
          "explanation": "clang-format est conçu pour le code C/C++ et permet d'appliquer un style uniforme."
        }
      ],
      "minTimeRead": "8",
      "difficulty": "EASY"
    },

    {
      "lessonId": "l6",
      "title": "Debugging et outils pour la qualité du code",
      "content": [
        { "type": "title", "value": "gdb et exécution pas-à-pas" },
        { "type": "text", "value": "gdb permet d'exécuter le programme pas à pas, d'inspecter les variables et de comprendre l'origine des crashs." },
        { "type": "code", "language": "bash", "value": "gcc -g main.c -o main\ngdb ./main\n# Dans gdb : run ; break main ; next ; print var" },
        { "type": "smallTitle", "value": "Détection des fuites mémoire (valgrind)" },
        { "type": "text", "value": "Valgrind détecte fuites mémoire et accès invalides : `valgrind --leak-check=full ./main`." },
        { "type": "note", "value": "Valgrind n'est pas disponible nativement sur toutes les plateformes (ex : Windows). Utilisez des outils alternatifs ou des environnements Linux." },
        { "type": "exercise", "value": "Introduisez volontairement une fuite mémoire (malloc sans free) et analysez le rapport valgrind.", "indication": "Comparez la sortie avant/après correction." },
        {
          "type": "quiz",
          "question": "Quel outil est le plus adapté pour détecter fuites mémoire sous Linux ?",
          "options": ["gdb", "valgrind", "strace"],
          "answer": 1,
          "explanation": "Valgrind est dédié à la détection de fuites mémoire et d'accès invalides."
        }
      ],
      "minTimeRead": "12",
      "difficulty": "MEDIUM"
    },

    {
      "lessonId": "l7",
      "title": "Mini-projet guidé : utilitaire d'analyse de texte",
      "content": [
        { "type": "title", "value": "Objectif du mini-projet" },
        { "type": "text", "value": "Écrire un programme qui lit une ligne depuis stdin et affiche : longueur (sans \\n), nombre de mots et nombre de voyelles. L'accent est mis sur la robustesse (gestion des limites de buffer) et la modularité (fonctions séparées)." },
        { "type": "smallTitle", "value": "Plan recommandé" },
        { "type": "text", "value": "1) Définir une fonction `read_line` sûre.\n2) Implémenter `count_words`, `count_vowels`, `strlen_safe`.\n3) Écrire des tests manuels (entrées variées) et vérifier les résultats." },
        { "type": "code", "language": "c", "value": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint count_vowels(const char *s) {\n    int count = 0; while (*s) { char c = tolower((unsigned char)*s++); if (c=='a'||c=='e'||c=='i'||c=='o'||c=='u'||c=='y') count++; } return count; }\n\nint main(void) {\n    char buf[1024];\n    if (!fgets(buf, sizeof(buf), stdin)) return 1;\n    size_t len = strlen(buf); if (len && buf[len-1]=='\\n') buf[--len]='\\0';\n    printf(\"Longueur: %zu\\n\", len);\n    printf(\"Voyelles: %d\\n\", count_vowels(buf));\n    return 0;\n}" },
        { "type": "exercise", "value": "Implémentez le programme complet et ajoutez la détection du nombre de mots.", "indication": "Pour compter les mots, parcourez la chaine et comptez les transitions non-espace → espace." },
        {
          "type": "quiz",
          "question": "Quelle fonction est plus sûre pour lire une ligne dans un buffer de taille fixe ?",
          "options": ["gets", "fgets", "scanf(\"%s\")"],
          "answer": 1,
          "explanation": "`fgets` permet de limiter la lecture à la taille du buffer et évite les débordements."
        }
      ],
      "minTimeRead": "20",
      "difficulty": "MEDIUM"
    },

    {
      "lessonId": "l8",
      "title": "Erreurs courantes et checklist de fin de chapitre",
      "content": [
        { "type": "title", "value": "Pièges, erreurs et comment les éviter" },
        { "type": "text", "value": "Liste non exhaustive :\n- Oublier de libérer la mémoire allouée (memory leak).\n- Accéder hors limites (buffer overflow).\n- Utiliser des formats `printf` incorrects (`%d` vs `%ld`).\n- Ignorer les warnings du compilateur." },
        { "type": "warning", "value": "Ne jamais ignorer les warnings importants : ils préviennent souvent de problèmes réels." },
        { "type": "smallTitle", "value": "Checklist de validation" },
        { "type": "text", "value": "1) Tous les programmes compilent avec `-Wall -Wextra` sans erreurs bloquantes.\n2) Les tests manuels du mini-projet couvrent cas limites (string vide, très long, caractères spéciaux).\n3) Le code est formaté et commenté lorsque nécessaire.\n4) Les erreurs de ressources (fopen, malloc) sont gérées." },
        { "type": "exercise", "value": "Faites passer votre mini-projet par la checklist et corrigez tous les items manquants.", "indication": "Ajoutez des vérifications `if (ptr==NULL)` après malloc et testez." },
        {
          "type": "quiz",
          "question": "Que devez-vous faire après avoir alloué une zone mémoire avec malloc ?",
          "options": [
            "Rien, le système la libère automatiquement",
            "Tester le pointeur et appeler free() quand vous avez fini",
            "Utiliser strcpy sans vérification"
          ],
          "answer": 1,
          "explanation": "Après malloc il faut vérifier que le pointeur n'est pas NULL et libérer la mémoire avec free() lorsqu'elle n'est plus utile."
        }
      ],
      "minTimeRead": "9",
      "difficulty": "MEDIUM"
    }
  ]
}


  ]
}
